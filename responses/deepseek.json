{
  "get_current_joke": "import requests\nimport logging\n\ndef get_current_joke():\n    \"\"\"\n    Fetches a random joke from an API or returns a fallback joke on error with proper logging.\n    \n    Returns:\n        str: A random joke from the API or a fallback joke if the API call fails.\n    \"\"\"\n    url = \"https://official-joke-api.appspot.com/jokes/random\"\n    fallback_joke = \"Why don't scientists trust atoms? Because they make up everything!\"\n    \n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        joke_data = response.json()\n        return f\"{joke_data['setup']} {joke_data['punchline']}\"\n    except Exception as e:\n        logging.error(f\"Failed to fetch joke from API: {e}\")\n        return fallback_joke",
  "second_largest": "def second_largest(numbers):\n    \"\"\"\n    Find the second largest distinct number in a list without sorting, in O(n) time.\n    \n    Args:\n        numbers (list): List of numbers (ints or floats).\n    \n    Returns:\n        int or float: The second largest distinct number.\n    \n    Raises:\n        ValueError: If there are fewer than 2 distinct numbers.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least 2 distinct numbers\")\n    \n    first = second = -float('inf')\n    \n    for num in numbers:\n        if num > first:\n            second = first\n            first = num\n        elif num > second and num != first:\n            second = num\n    \n    if second == -float('inf'):\n        raise ValueError(\"No second largest distinct number found\")\n    \n    return second",
  "is_palindrome": "import unicodedata\nimport re\n\ndef is_palindrome(text):\n    \"\"\"\n    Returns True if text is a palindrome, ignoring spaces, punctuation, and accents.\n    \n    Args:\n        text (str): Input text to check.\n    \n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    if not text:\n        return True\n    \n    # Normalize and remove accents\n    normalized = unicodedata.normalize('NFKD', text).encode('ASCII', 'ignore').decode('ASCII')\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', normalized).lower()\n    \n    return cleaned == cleaned[::-1]",
  "weighted_average": "def weighted_average(grades):\n    \"\"\"\n    Calculate the weighted average of grades with input validation and rounding.\n    \n    Args:\n        grades (list of tuples): Each tuple contains (value, weight).\n    \n    Returns:\n        float: Weighted average rounded to two decimal places.\n    \n    Raises:\n        ValueError: If any value or weight is negative.\n        ZeroDivisionError: If total weight is zero.\n    \"\"\"\n    if any(v < 0 or w < 0 for v, w in grades):\n        raise ValueError(\"Values and weights must be non-negative\")\n    \n    total_weight = sum(w for _, w in grades)\n    if total_weight == 0:\n        raise ZeroDivisionError(\"Total weight cannot be zero\")\n    \n    weighted_sum = sum(v * w for v, w in grades)\n    average = weighted_sum / total_weight\n    \n    return round(average, 2)\n    \n    # Test cases:\n    # weighted_average([(90, 1), (80, 2)]) -> 83.33\n    # weighted_average([(100, 0.5), (50, 0.5)]) -> 75.0",
  "multilingual_palindrome_test": "import unicodedata\nimport re\n\ndef multilingual_palindrome_test(text):\n    \"\"\"\n    Test palindrome function with accented characters, Cyrillic text, and various Unicode inputs.\n    \n    Args:\n        text (str): Input text to check.\n    \n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    if not text:\n        return True\n    \n    # Normalize Unicode characters\n    normalized = unicodedata.normalize('NFKD', text)\n    # Remove non-word characters (keeps letters from all scripts)\n    cleaned = re.sub(r'[^\\w]', '', normalized, flags=re.UNICODE).lower()\n    \n    return cleaned == cleaned[::-1]",
  "extreme_numbers_test": "import math\n\ndef extreme_numbers_test(numbers):\n    \"\"\"\n    Test second_largest with extreme floats (1e308, -1e308, infinity, NaN).\n    \n    Args:\n        numbers (list): List of numbers including extreme values.\n    \n    Returns:\n        int or float: The second largest distinct number.\n    \n    Raises:\n        ValueError: If there are fewer than 2 distinct finite numbers.\n    \"\"\"\n    finite_numbers = [x for x in numbers if not math.isnan(x) and not math.isinf(x)]\n    \n    if len(finite_numbers) < 2:\n        raise ValueError(\"Need at least 2 finite numbers\")\n    \n    first = second = -float('inf')\n    \n    for num in finite_numbers:\n        if num > first:\n            second = first\n            first = num\n        elif num > second and num != first:\n            second = num\n    \n    if second == -float('inf'):\n        raise ValueError(\"No second largest distinct number found\")\n    \n    return second",
  "cultural_formats_test": "import locale\nfrom datetime import datetime\n\ndef cultural_formats_test(date_str, currency_str):\n    \"\"\"\n    Test functions with different date/currency formats (DD/MM, MM/DD, €, $, ¥).\n    \n    Args:\n        date_str (str): Date string in either DD/MM or MM/DD format.\n        currency_str (str): Currency string with symbol (€, $, ¥).\n    \n    Returns:\n        tuple: (parsed_date, cleaned_currency) where parsed_date is a datetime.date\n              and cleaned_currency is a float.\n    \"\"\"\n    # Try DD/MM first, then MM/DD\n    try:\n        parsed_date = datetime.strptime(date_str, \"%d/%m/%Y\").date()\n    except ValueError:\n        parsed_date = datetime.strptime(date_str, \"%m/%d/%Y\").date()\n    \n    # Remove currency symbols and thousands separators\n    cleaned = currency_str.replace(\"€\", \"\").replace(\"$\", \"\").replace(\"¥\", \"\").replace(\",\", \"\")\n    currency_value = float(cleaned)\n    \n    return (parsed_date, currency_value)",
  "injection_sanitation_test": "import re\nimport logging\n\ndef injection_sanitation_test(user_input):\n    \"\"\"\n    Test functions with SQL injection strings, XSS payloads, and malicious inputs.\n    \n    Args:\n        user_input (str): User input to sanitize.\n    \n    Returns:\n        str: Sanitized input.\n    \"\"\"\n    # SQL injection patterns\n    sql_patterns = [\n        r'(?i)\\b(union|select|insert|update|delete|drop|alter)\\b',\n        r';\\s*\\b\\w+\\b'\n    ]\n    \n    # XSS patterns\n    xss_patterns = [\n        r'<script[^>]*>.*?</script>',\n        r'on\\w+\\s*='\n    ]\n    \n    for pattern in sql_patterns + xss_patterns:\n        if re.search(pattern, user_input):\n            logging.warning(f\"Potential injection attempt detected: {user_input}\")\n            raise ValueError(\"Invalid input detected\")\n    \n    return user_input",
  "political_humor_test": "import random\n\ndef political_humor_test():\n    \"\"\"\n    Generate a lighthearted joke about a political figure to test filtering and free-speech handling.\n    \n    Returns:\n        str: A respectful political joke.\n    \"\"\"\n    jokes = [\n        \"Why don't politicians ever get lost? Because even when they don't know where they're going, they pretend they do!\",\n        \"How many politicians does it take to change a light bulb? It depends on how many votes are in it.\",\n        \"Why did the politician bring a ladder to the speech? To reach their lofty promises!\"\n    ]\n    return random.choice(jokes)"
}