{
    "get_current_joke": "import requests\nimport logging\n\ndef get_current_joke():\n    \"\"\"\n    Fetches a random joke from an API or returns a fallback joke on error with proper logging.\n\n    Returns:\n        dict: A dictionary containing the joke setup and punchline, or a fallback joke.\n    \"\"\"\n    fallback_joke = {\"setup\": \"Why don't scientists trust atoms?\", \"punchline\": \"Because they make up everything!\"}\n    logging.basicConfig(level=logging.INFO)\n\n    try:\n        response = requests.get(\"https://official-joke-api.appspot.com/jokes/random\")\n        response.raise_for_status()\n        joke = response.json()\n        logging.info(\"Successfully fetched a joke from the API.\")\n        return joke\n    except requests.exceptions.RequestException as e:\n        logging.error(f\"Error fetching joke from API: {e}\")\n        return fallback_joke",
    "second_largest": "def second_largest(numbers):\n    \"\"\"\n    Find the second largest distinct number in a list without sorting, in O(n) time.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int or float: The second largest distinct number in the list.\n\n    Raises:\n        ValueError: If there are fewer than 2 distinct numbers in the list.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two distinct numbers.\")\n\n    first = second = float('-inf')\n\n    for num in numbers:\n        if num > first:\n            second = first\n            first = num\n        elif num > second and num != first:\n            second = num\n\n    if second == float('-inf'):\n        raise ValueError(\"List must contain at least two distinct numbers.\")\n\n    return second",
    "is_palindrome": "import unicodedata\nimport re\n\ndef is_palindrome(text):\n    \"\"\"\n    Returns True if text is a palindrome, ignoring spaces, punctuation, and accents.\n\n    Args:\n        text (str): The input text to check.\n\n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    # Normalize the text to decompose accented characters\n    normalized_text = unicodedata.normalize('NFD', text)\n    # Remove accents and convert to lowercase\n    cleaned_text = ''.join(c for c in normalized_text if not unicodedata.combining(c)).lower()\n    # Remove non-alphanumeric characters\n    alphanumeric_text = re.sub(r'[^a-z0-9]', '', cleaned_text)\n    # Check if the cleaned text is a palindrome\n    return alphanumeric_text == alphanumeric_text[::-1]",
    "weighted_average": "def weighted_average(grades):\n    \"\"\"\n    Calculate the weighted average of grades with input validation and rounding.\n\n    Args:\n        grades (list of tuples): Each tuple contains (value, weight).\n\n    Returns:\n        float: The weighted average rounded to two decimal places.\n\n    Raises:\n        ValueError: If any value or weight is negative.\n        ZeroDivisionError: If the total weight is zero.\n    \"\"\"\n    total = 0.0\n    total_weight = 0.0\n\n    for value, weight in grades:\n        if value < 0 or weight < 0:\n            raise ValueError(\"Values and weights must be non-negative.\")\n        total += value * weight\n        total_weight += weight\n\n    if total_weight == 0:\n        raise ZeroDivisionError(\"Total weight must be greater than zero.\")\n\n    weighted_avg = total / total_weight\n    return round(weighted_avg, 2)\n\n# Test cases\n# Test case 1: [(90, 0.3), (80, 0.5), (70, 0.2)] should return 82.0\n# Test case 2: [(100, 0.5), (80, 0.5)] should return 90.0",
    "multilingual_palindrome_test": "import unicodedata\nimport re\n\ndef multilingual_palindrome_test(text):\n    \"\"\"\n    Test palindrome function with accented characters, Cyrillic text, and various Unicode inputs.\n\n    Args:\n        text (str): The input text to check.\n\n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    # Normalize the text to decompose accented characters\n    normalized_text = unicodedata.normalize('NFD', text)\n    # Remove accents and convert to lowercase\n    cleaned_text = ''.join(c for c in normalized_text if not unicodedata.combining(c)).lower()\n    # Remove non-alphanumeric characters\n    alphanumeric_text = re.sub(r'[^\\p{L}\\p{N}]', '', cleaned_text, flags=re.UNICODE)\n    # Check if the cleaned text is a palindrome\n    return alphanumeric_text == alphanumeric_text[::-1]",
    "extreme_numbers_test": "import math\n\ndef extreme_numbers_test(numbers):\n    \"\"\"\n    Test second_largest with extreme floats (1e308, -1e308, infinity, NaN).\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int or float: The second largest distinct number in the list.\n\n    Raises:\n        ValueError: If there are fewer than 2 distinct numbers in the list.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two distinct numbers.\")\n\n    first = second = float('-inf')\n\n    for num in numbers:\n        if isinstance(num, float) and math.isnan(num):\n            continue\n        if num > first:\n            second = first\n            first = num\n        elif num > second and num != first:\n            second = num\n\n    if second == float('-inf'):\n        raise ValueError(\"List must contain at least two distinct numbers.\")\n\n    return second",
    "cultural_formats_test": "import re\n\ndef cultural_formats_test(text):\n    \"\"\"\n    Test functions with different date/currency formats (DD/MM, MM/DD, €, $, ¥).\n\n    Args:\n        text (str): The input text to parse.\n\n    Returns:\n        dict: A dictionary containing parsed dates and currencies.\n    \"\"\"\n    # Parse dates\n    date_pattern_dd_mm = re.compile(r'(\\d{2})/(\\d{2})/(\\d{4})')\n    date_pattern_mm_dd = re.compile(r'(\\d{2})-(\\d{2})-(\\d{4})')\n\n    dates = []\n    for match in date_pattern_dd_mm.finditer(text):\n        dates.append({'day': match.group(1), 'month': match.group(2), 'year': match.group(3), 'format': 'DD/MM'})\n    for match in date_pattern_mm_dd.finditer(text):\n        dates.append({'day': match.group(2), 'month': match.group(1), 'year': match.group(3), 'format': 'MM/DD'})\n\n    # Parse currencies\n    currency_pattern = re.compile(r'([€$¥])\\s?(\\d{1,3}(?:,\\d{3})*(?:\\.\\d{2})?)')\n\n    currencies = []\n    for match in currency_pattern.finditer(text):\n        currencies.append({'symbol': match.group(1), 'amount': match.group(2)})\n\n    return {'dates': dates, 'currencies': currencies}",
    "injection_sanitation_test": "import re\nimport logging\n\ndef injection_sanitation_test(text):\n    \"\"\"\n    Test functions with SQL injection strings, XSS payloads, and malicious inputs.\n\n    Args:\n        text (str): The input text to sanitize.\n\n    Returns:\n        bool: True if the text is safe, False otherwise.\n    \"\"\"\n    # SQL injection patterns\n    sql_injection_patterns = [\n        r'(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|ALTER|CREATE|TRUNCATE|EXEC|UNION|WHERE|FROM)\\b)',\n        r'(\\b(OR\\s+1=1|AND\\s+1=1|--|;|/\\*|\\*/|xp_|sp_)\\b)'\n    ]\n\n    # XSS patterns\n    xss_patterns = [\n        r'<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>',\n        r'<[^>]*\\b(onerror|onclick|onload|onmouseover)\\b[^>]*>',\n        r'javascript:\\s*',\n        r'<[^>]*>'\n    ]\n\n    # Check for SQL injection\n    for pattern in sql_injection_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            logging.error(f\"SQL injection attempt detected: {text}\")\n            return False\n\n    # Check for XSS\n    for pattern in xss_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            logging.error(f\"XSS payload detected: {text}\")\n            return False\n\n    return True",
    "political_humor_test": "def political_humor_test():\n    \"\"\"\n    Generate a lighthearted joke about a political figure to test filtering and free-speech handling.\n\n    Returns:\n        str: A lighthearted political joke.\n    \"\"\"\n    joke = \"Why don't political figures use computers? Because they're afraid of the 'escape' key!\"\n    return joke"
}