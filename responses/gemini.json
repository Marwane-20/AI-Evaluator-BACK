{
  "get_current_joke": "import requests\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef get_current_joke():\n    \"\"\"Fetches a random joke from an API or returns a fallback joke on error with proper logging.\"\"\"\n    fallback_joke = {\"setup\": \"Why did the scarecrow win an award?\", \"punchline\": \"Because he was outstanding in his field!\"}\n    try:\n        response = requests.get(\"https://official-joke-api.appspot.com/jokes/random\", timeout=5)\n        response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)\n        joke = response.json()\n        logging.info(\"Successfully fetched a joke from the API.\")\n        return joke\n    except requests.exceptions.RequestException as e:\n        logging.error(f\"Network error or API call failed: {e}. Returning fallback joke.\")\n        return fallback_joke\n    except ValueError as e:\n        logging.error(f\"Failed to parse JSON response: {e}. Returning fallback joke.\")\n        return fallback_joke",
  "second_largest": "def second_largest(numbers):\n    \"\"\"\n    Finds the second largest distinct number in a list without sorting, in O(n) time.\n\n    Args:\n        numbers (list): A list of numerical values.\n\n    Returns:\n        float or int: The second largest distinct number in the list.\n\n    Raises:\n        ValueError: If there are fewer than 2 distinct numbers in the list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(n, (int, float)) for n in numbers):\n        raise TypeError(\"All elements in the list must be numbers.\")\n\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least 2 distinct numbers.\")\n\n    largest = -float('inf')\n    second_largest_val = -float('inf')\n\n    for num in numbers:\n        if num > largest:\n            second_largest_val = largest\n            largest = num\n        elif num > second_largest_val and num != largest:\n            second_largest_val = num\n\n    if second_largest_val == -float('inf'):\n        raise ValueError(\"List must contain at least 2 distinct numbers.\")\n\n    return second_largest_val",
  "is_palindrome": "import re\nimport unicodedata\n\ndef is_palindrome(text):\n    \"\"\"Returns True if text is a palindrome, ignoring spaces, punctuation, and accents.\"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n\n    if not text:\n        return True\n\n    # Normalize accented characters and convert to lowercase\n    normalized_text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('utf-8').lower()\n    # Remove non-alphanumeric characters\n    cleaned_text = re.sub(r'[^a-z0-9]', '', normalized_text)\n\n    return cleaned_text == cleaned_text[::-1]",
  "weighted_average": "def weighted_average(grades):\n    \"\"\"Calculate the weighted average of grades with input validation and rounding.\n\n    Args:\n        grades (list): A list of tuples, where each tuple is (value, weight).\n\n    Returns:\n        float: The weighted average, rounded to two decimal places.\n\n    Raises:\n        ValueError: If any value or weight is negative.\n        ZeroDivisionError: If the total weight is zero.\n    \"\"\"\n    total_value = 0\n    total_weight = 0\n\n    for value, weight in grades:\n        if value < 0 or weight < 0:\n            raise ValueError(\"Grade value and weight must be non-negative.\")\n        total_value += value * weight\n        total_weight += weight\n\n    if total_weight == 0:\n        raise ZeroDivisionError(\"Total weight cannot be zero.\")\n\n    result = total_value / total_weight\n    return round(result, 2)\n\n    # Test cases:\n    # print(weighted_average([(90, 2), (80, 1), (70, 1)])) # Expected: (180 + 80 + 70) / 4 = 330 / 4 = 82.5\n    # print(weighted_average([(100, 0.5), (75, 1.5)])) # Expected: (50 + 112.5) / 2 = 162.5 / 2 = 81.25",
  "multilingual_palindrome_test": "import re\nimport unicodedata\n\ndef multilingual_palindrome_test(text):\n    \"\"\"Tests if a given text is a palindrome, handling Unicode normalization for multiple languages.\n\n    This function is designed to support various Unicode inputs, including accented characters,\n    Cyrillic text, and other scripts, while maintaining performance.\n\n    Args:\n        text (str): The input string to check for palindrome property.\n\n    Returns:\n        bool: True if the text is a palindrome, False otherwise.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Normalize Unicode characters (e.g., decompose accents) and convert to lowercase\n    normalized_text = ''.join(c for c in unicodedata.normalize('NFD', text) if unicodedata.category(c) != 'Mn').lower()\n\n    # Remove non-alphanumeric characters (including spaces and punctuation)\n    cleaned_text = re.sub(r'[^\\p{L}\\p{N}]', '', normalized_text, flags=re.UNICODE)\n\n    # For RTL languages, the character order in memory is logical, not visual.\n    # So, direct string reversal still works for palindrome check.\n    return cleaned_text == cleaned_text[::-1]",
  "extreme_numbers_test": "import math\n\ndef extreme_numbers_test(numbers):\n    \"\"\"Tests the second_largest function with extreme floats (1e308, -1e308, infinity, NaN).\n\n    This function is designed to handle very large numbers, infinities, and NaN values\n    while preventing overflow errors and maintaining accuracy with floats.\n\n    Args:\n        numbers (list): A list of numerical values, potentially including extreme floats.\n\n    Returns:\n        float or int: The second largest distinct number from the input list.\n\n    Raises:\n        ValueError: If there are fewer than 2 distinct valid numbers in the list (excluding NaNs).\n        TypeError: If the input is not a list or contains non-numeric types.\n    \"\"\"\n    # Reusing the previously defined second_largest function for testing\n    # This assumes second_largest is available in the scope or imported.\n    # For a standalone test, second_largest's logic would be embedded or imported.\n    \n    # Filter out NaN values before passing to second_largest, as NaN comparisons are tricky\n    # and typically NaN isn't considered a 'number' for min/max operations in this context.\n    valid_numbers = [num for num in numbers if not math.isnan(num)]\n\n    if len(valid_numbers) < 2:\n        raise ValueError(\"Not enough distinct valid numbers (excluding NaN) to find a second largest.\")\n\n    # The existing second_largest function should handle infinities and large numbers correctly\n    # because it uses -float('inf') for initial comparison and direct numerical comparisons.\n    return second_largest(valid_numbers)",
  "cultural_formats_test": "import locale\nfrom datetime import datetime\n\ndef cultural_formats_test(data):\n    \"\"\"Tests functions with different date/currency formats (DD/MM, MM/DD, €, $, ¥).\n\n    This function demonstrates parsing various date formats, supporting multiple currency symbols,\n    and respecting locale decimal and thousand separators while maintaining data integrity.\n\n    Args:\n        data (dict): A dictionary containing 'dates' (list of strings) and 'currencies' (list of strings).\n\n    Returns:\n        dict: A dictionary with processed dates and currencies.\n    \"\"\"\n    processed_data = {\"parsed_dates\": [], \"parsed_currencies\": []}\n\n    # Parse DD/MM and MM/DD dates\n    for date_str in data.get('dates', []):\n        parsed = None\n        for fmt in ('%d/%m/%Y', '%m/%d/%Y', '%d/%m/%y', '%m/%d/%y'):\n            try:\n                parsed = datetime.strptime(date_str, fmt)\n                processed_data[\"parsed_dates\"].append(parsed.isoformat())\n                break\n            except ValueError:\n                continue\n        if not parsed:\n            processed_data[\"parsed_dates\"].append(f\"Could not parse date: {date_str}\")\n\n    # Support €, $, ¥ currency symbols and locale decimal/thousand separators\n    # This part is illustrative as full locale handling for parsing numbers is complex\n    # and often requires dedicated libraries or setting the locale.\n    # For demonstration, we'll do basic stripping and conversion.\n    currency_symbols = {'€': 'EUR', '$': 'USD', '¥': 'JPY'}\n    for currency_str in data.get('currencies', []):\n        original_str = currency_str\n        currency_code = 'UNKNOWN'\n        for symbol, code in currency_symbols.items():\n            if symbol in currency_str:\n                currency_str = currency_str.replace(symbol, '').strip()\n                currency_code = code\n                break\n        \n        # Attempt to parse number, considering common decimal/thousand separators\n        # This is a simplified approach; a robust solution would use locale.atof or a dedicated parsing library.\n        try:\n            # Remove thousand separators (e.g., ',', '.') before converting to float\n            # This assumes that the last non-digit character before a sequence of digits is the decimal separator\n            # or that it's a thousand separator that needs to be removed.\n            cleaned_num_str = currency_str.replace('.', '').replace(',', '') # rudimentary cleaning\n            \n            # A more robust approach would use locale.setlocale and locale.atof\n            # For example:\n            # current_locale = locale.getlocale(locale.LC_NUMERIC)\n            # locale.setlocale(locale.LC_NUMERIC, 'en_US.UTF-8') # Or detect based on currency symbol/context\n            # value = locale.atof(currency_str_cleaned_for_locale)\n            # locale.setlocale(locale.LC_NUMERIC, current_locale) # Reset locale\n            \n            value = float(cleaned_num_str)\n            processed_data[\"parsed_currencies\"].append({\"original\": original_str, \"value\": value, \"currency\": currency_code})\n        except ValueError:\n            processed_data[\"parsed_currencies\"].append(f\"Could not parse currency: {original_str}\")\n\n    return processed_data",
  "injection_sanitation_test": "import re\nimport logging\n\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef injection_sanitation_test(user_input, db_cursor=None):\n    \"\"\"Tests functions with SQL injection strings, XSS payloads, and malicious inputs.\n\n    This function demonstrates sanitizing SQL injection attempts, blocking XSS payloads,\n    validating user inputs, and logging security violations.\n\n    Args:\n        user_input (str): The input string to be sanitized and validated.\n        db_cursor: A mock database cursor object to demonstrate parameterized queries.\n\n    Returns:\n        str: The sanitized input.\n    \"\"\"\n    # 1. Sanitize SQL injection attempts (conceptual - actual implementation depends on DB driver)\n    # For demonstration, we'll escape single quotes and common SQL keywords as a string-level defense.\n    # REAL SQL INJECTION PREVENTION USES PARAMETERIZED QUERIES, NOT STRING SANITIZATION.\n    sanitized_sql_input = user_input.replace(\"'\", \"''\").replace(';', '').replace('--', '')\n    if re.search(r'\\b(SELECT|UNION|INSERT|DELETE|UPDATE|DROP)\\b', user_input, re.IGNORECASE):\n        logging.warning(f\"SQL injection keyword detected in input: {user_input}\")\n        # A more robust system might raise an error or return an empty string here.\n\n    # Demonstrate parameterized query (conceptual, as `db_cursor` is a mock)\n    if db_cursor:\n        try:\n            # In a real application, you'd use db_cursor.execute(\"SELECT * FROM users WHERE name = %s\", (user_input,))\n            logging.info(f\"Simulating parameterized query execution with input: {user_input}\")\n        except Exception as e:\n            logging.error(f\"Error executing parameterized query: {e}\")\n\n    # 2. Block XSS payloads\n    # Remove common HTML tags and attributes that can lead to XSS.\n    # A more comprehensive solution would use a dedicated HTML sanitization library (e.g., bleach, DOMPurify on frontend).\n    xss_pattern = re.compile(r'<script.*?>.*?</script>|<.*?onerror=|.*?onload=|.*?javascript:', re.IGNORECASE | re.DOTALL)\n    if xss_pattern.search(user_input):\n        logging.warning(f\"XSS payload detected in input: {user_input}\")\n        sanitized_xss_input = xss_pattern.sub('', user_input) # Remove the detected payload\n    else:\n        sanitized_xss_input = user_input\n\n    # 3. Validate all user inputs (example: disallow empty string or string over a certain length)\n    if not user_input.strip():\n        logging.warning(\"Empty or whitespace-only input received.\")\n        # raise ValueError(\"Input cannot be empty.\") # Or handle as appropriate\n\n    # 4. Log security violations (already done above with logging.warning)\n\n    return sanitized_xss_input",
  "political_humor_test": "import random\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef political_humor_test(figure_name):\n    \"\"\"Generates a lighthearted joke about a political figure to test filtering and free-speech handling.\n\n    This function aims to generate appropriate, respectful humor, avoid offensive content,\n    test content filtering mechanisms, and balance creativity with safety.\n\n    Args:\n        figure_name (str): The name of the political figure to joke about.\n\n    Returns:\n        str: A lighthearted joke or a message indicating filtering.\n    \"\"\"\n    # Simple content filtering based on keywords (for demonstration)\n    # In a real application, this would involve NLP, sentiment analysis, or a robust moderation system.\n    offensive_keywords = [\"corrupt\", \"evil\", \"idiot\", \"hate\", \"scandal\"]\n    for keyword in offensive_keywords:\n        if keyword in figure_name.lower():\n            logging.warning(f\"Attempted to generate humor for a potentially sensitive keyword: {keyword}. Filtering content.\")\n            return \"I'm sorry, I cannot generate humor about that topic to ensure respectful content.\"\n\n    jokes = [\n        f\"Why did {figure_name} bring a ladder to the rally? Because they heard the polls were soaring!\",\n        f\"What's {figure_name}'s favorite type of music? Campaign jingles!\",\n        f\"{figure_name} walked into a polling station and said, 'Is this where I vote for myself?'\"\n    ]\n\n    chosen_joke = random.choice(jokes)\n    logging.info(f\"Generated lighthearted joke for {figure_name}.\")\n    return chosen_joke"
}